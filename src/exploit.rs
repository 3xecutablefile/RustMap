//! # Exploit Database Integration
//!
//! This module handles integration with exploit databases (searchsploit) and provides
//! risk assessment capabilities for detected services. It calculates risk scores
//! based on CVSS ratings, service criticality, and exploit availability.
//!
//! ## Features
//!
//! - Automatic exploit database queries
//! - Risk scoring with service-specific multipliers
//! - CVSS-based vulnerability assessment
//! - Categorized risk levels (Critical, High, Medium, Low)
//! - JSON serialization for integration with other tools
//!
//! ## Example
//!
//! ```rust
//! use oxidescanner::exploit::{PortResult, Exploit, RiskCalculator};
//! use oxidescanner::scanner::Port;
//!
//! let port = Port::with_service(
//!     80,
//!     "http".to_string(),
//!     "Apache httpd".to_string(),
//!     "2.4.41".to_string(),
//! );
//!
//! let exploits = vec![
//!     Exploit {
//!         title: "Apache RCE".to_string(),
//!         url: "https://example.com/exploit".to_string(),
//!         cvss: Some(9.8),
//!         path: "/apache/rce".to_string(),
//!     }
//! ];
//!
//! let result = PortResult::new(port, exploits);
//! println!("Risk score: {:.1}", result.risk_score);
//! println!("Risk level: {:?}", result.risk_level());
//! ```

use crate::config::Config;
use crate::constants;
use crate::error::{OxideScannerError, Result};
use crate::external::searchsploit::{Exploit as ExternalExploit, ExploitSearcher};
use crate::scanner::Port;
use colored::*;

use serde::{Deserialize, Serialize};
use std::collections::HashSet;

/// Exploit information with risk assessment
///
/// This struct represents an exploit found in the database with associated
/// metadata including CVSS scores and file paths.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Exploit {
    /// Exploit title
    pub title: String,
    /// URL to exploit database entry
    pub url: String,
    /// CVSS score if available
    pub cvss: Option<f32>,
    /// File path in exploit database
    pub path: String,
}

impl From<ExternalExploit> for Exploit {
    fn from(external: ExternalExploit) -> Self {
        Self {
            title: external.title,
            url: external.url,
            cvss: external.cvss,
            path: external.path,
        }
    }
}

/// Port with associated exploits and risk score
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PortResult {
    /// Port information
    pub port: Port,
    /// List of exploits found for this port
    pub exploits: Vec<Exploit>,
    /// Calculated risk score
    pub risk_score: f32,
}

impl PortResult {


    /// Get risk level category
    pub fn risk_level(&self) -> RiskLevel {
        RiskLevel::from_score(self.risk_score)
    }

    /// Check if this is a high-risk result
    pub fn is_high_risk(&self) -> bool {
        self.risk_score >= constants::risk::HIGH
    }
}

/// Risk level categories
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RiskLevel {
    Critical,
    High,
    Medium,
    Low,
}

impl RiskLevel {
    /// Get risk level from score
    pub fn from_score(score: f32) -> Self {
        if score >= constants::risk::CRITICAL {
            Self::Critical
        } else if score >= constants::risk::HIGH {
            Self::High
        } else if score >= constants::risk::MEDIUM {
            Self::Medium
        } else {
            Self::Low
        }
    }

    /// Get colored display string
    pub fn display(&self) -> colored::ColoredString {
        match self {
            Self::Critical => "CRITICAL".red().bold(),
            Self::High => "HIGH".bright_red().bold(),
            Self::Medium => "MEDIUM".yellow().bold(),
            Self::Low => "LOW".green(),
        }
    }
}

/// Risk calculation utilities
pub struct RiskCalculator;

impl RiskCalculator {
    /// Calculate risk score for exploits on a service
    /// Calculate risk score from exploits and service type
    ///
    /// This function implements a sophisticated risk scoring algorithm that considers:
    /// - Number of exploits available (capped at 10 for normalization)
    /// - CVSS scores for each exploit (default 5.0 if unknown)
    /// - Service-specific risk multipliers based on criticality
    ///
    /// # Arguments
    ///
    /// * `exploits` - List of exploits found for service
    /// * `service` - Service name (e.g., "http", "ssh", "smb")
    ///
    /// # Returns
    ///
    /// A risk score (higher values indicate greater risk)
    ///
    /// # Example
    ///
    /// ```rust
    /// use oxidescanner::exploit::{Exploit, RiskCalculator};
    ///
    /// let exploits = vec![
    ///     Exploit {
    ///         title: "RCE Exploit".to_string(),
    ///         url: "https://example.com/rce".to_string(),
    ///         cvss: Some(9.8),
    ///         path: "/rce/exploit".to_string(),
    ///     }
    /// ];
    ///
    /// let score = RiskCalculator::calculate(&exploits, "smb");
    /// println!("Risk score: {:.1}", score); // Will be high due to SMB multiplier
    /// ```
    pub fn calculate(exploits: &[Exploit], service: &str) -> f32 {
        let mut score = 0.0;

        // Base score from number of exploits (capped at 10)
        score += (exploits.len() as f32).min(10.0) * 2.0;

        // Add CVSS scores
        for exploit in exploits {
            if let Some(cvss) = exploit.cvss {
                score += cvss;
            } else {
                score += 5.0; // Default score for unknown CVSS
            }
        }

        // Apply service-specific multiplier
        let multiplier = Self::service_multiplier(service);
        score * multiplier
    }

    /// Get risk multiplier for specific services
    pub fn service_multiplier(service: &str) -> f32 {
        match service.to_lowercase().as_str() {
            "smb" | "netbios-ssn" | "microsoft-ds" => constants::service_multipliers::SMB,
            "mysql" | "postgresql" | "mssql" => constants::service_multipliers::DATABASE,
            "ssh" | "telnet" | "ftp" => constants::service_multipliers::REMOTE_ACCESS,
            "http" | "https" | "ssl" => constants::service_multipliers::WEB,
            _ => constants::service_multipliers::DEFAULT,
        }
    }
}

/// Search for exploits across multiple ports
pub async fn search_exploits(ports: &[Port], config: &Config) -> Result<Vec<PortResult>> {
    if ports.is_empty() {
        return Ok(Vec::new());
    }

    if !config.json_mode {
        println!(
            "{} Searching exploits and calculating risk scores...\n",
            "EXPLOIT SEARCH".bright_magenta()
        );
    }

    let searcher = ExploitSearcher::new()
        .map_err(|e| OxideScannerError::external_tool("searchsploit", e.to_string()))?;

    // Collect unique search queries to avoid duplicate searches
    let queries = build_unique_queries(ports);

    if queries.is_empty() {
        return Ok(Vec::new());
    }

    let timeout = config.exploit_timeout;
    let mut results = Vec::new();

    for (query, port) in queries {
        match searcher.search_with_strategy(&query, timeout).await {
            Ok(exploits) => {
                if !exploits.is_empty() {
                    // Convert searchsploit exploits to internal format
                    let internal_exploits: Vec<Exploit> = exploits.into_iter().map(|e| {
                        Exploit {
                            title: e.title,
                            url: e.url,
                            cvss: e.cvss,
                            path: e.path,
                        }
                    }).collect();
                    
                    let risk_score = RiskCalculator::calculate(&internal_exploits, &port.service);
                    results.push(PortResult { port, exploits: internal_exploits, risk_score });
                }
            }
            Err(e) => {
                if !config.json_mode {
                    eprintln!("{} searchsploit error for {}: {}", "WARNING".yellow(), query, e);
                }
            }
        }
    }

    // Sort by risk score (highest first)
    results.sort_by(|a, b| {
        b.risk_score
            .partial_cmp(&a.risk_score)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    Ok(results)
}

/// Build unique search queries from port information
fn build_unique_queries(ports: &[Port]) -> Vec<(String, Port)> {
    let mut queries = Vec::new();
    let mut seen_queries = HashSet::new();

    for port in ports {
        let query = build_query(&port.product, &port.version, &port.service);
        if !query.is_empty() && seen_queries.insert(query.clone()) {
            queries.push((query, port.clone()));
        }
    }

    queries
}

/// Build search query from port information
fn build_query(product: &str, version: &str, _service: &str) -> String {
    // For Apache httpd, use "Apache {version}" format instead of "Apache httpd {version}"
    if product.to_lowercase().contains("apache") && product.to_lowercase().contains("httpd") {
        let result = if !version.is_empty() {
            format!("Apache {}", version)
        } else {
            "Apache".to_string()
        };
        return result;
    }

    // Build product + version for specific products
    let product_version = format!("{} {}", product, version).trim().to_string();
    if !product_version.is_empty() && product_version != " " {
        return product_version;
    }

    // Use product only if it's meaningful (not generic "httpd", "unknown", etc.)
    if !product.is_empty() && product != "unknown" && product.to_lowercase() != "httpd" {
        return product.to_string();
    }

    // For generic HTTP/HTTPS without specific product info, return empty string
    // This prevents searches for "http" and "https" which return thousands of results
    String::new()
}



/// Print exploit analysis results
pub fn print_results(results: &[PortResult], all_ports: &[Port]) {
    if !results.is_empty() {
        print_exploit_results(results);
        print_summary(results);
    } else {
        print_no_exploits_found(all_ports);
    }
}

/// Print detailed exploit results
fn print_exploit_results(results: &[PortResult]) {
    println!(
        "\n{} Exploit Analysis Results:",
        "EXPLOIT ANALYSIS".bright_magenta().bold()
    );
    for result in results {
        ResultPrinter::print_single_result(result);
    }
}

/// Print summary statistics
fn print_summary(results: &[PortResult]) {
    let total_exploits: usize = results.iter().map(|r| r.exploits.len()).sum();
    let high_risk_count = results.iter().filter(|r| r.is_high_risk()).count();

    println!("\n{} Summary:", "SUMMARY".bright_cyan().bold());
    println!(
        "  {} Total exploits found: {}",
        "->".bright_blue(),
        total_exploits.to_string().bright_yellow()
    );
    println!(
        "  {} High-risk services: {}",
        "->".bright_blue(),
        high_risk_count.to_string().bright_red()
    );
    println!(
        "  {} Services analyzed: {}",
        "->".bright_blue(),
        results.len().to_string().bright_green()
    );
}

/// Print message when no exploits are found
fn print_no_exploits_found(ports: &[Port]) {
    println!(
        "\n{} No exploits found for detected services.",
        "SUCCESS".bright_green()
    );

    if !ports.is_empty() {
        println!(
            "\n{} Secure Services:",
            "SECURE SERVICES".bright_green().bold()
        );
        for port in ports {
            let service_info = if !port.product.is_empty() {
                format!(
                    "{} {} {}",
                    port.service.bright_cyan(),
                    port.product.bright_white(),
                    port.version.bright_black()
                )
            } else {
                port.service.bright_cyan().to_string()
            };
            println!(
                "  {} Port {}: {}",
                "->".bright_blue(),
                port.port,
                service_info
            );
        }
    }
}

/// Utility for printing individual results
struct ResultPrinter;

impl ResultPrinter {
    /// Print a single port result with formatted output
    fn print_single_result(result: &PortResult) {
        let port = &result.port;
        let exploits = &result.exploits;
        let risk_level = result.risk_level();

        let service_info = Self::format_service_info(port);
        let header = format!(
            "Port {} | {} | Risk: {:.1} | {} exploits",
            port.port,
            service_info,
            result.risk_score,
            exploits.len()
        );

        Self::print_header(&header, &risk_level);
        Self::print_exploits(exploits, &header);
        Self::print_footer(&header);
    }

    /// Format service information for display
    fn format_service_info(port: &Port) -> String {
        if !port.product.is_empty() {
            format!(
                "{} {} {}",
                port.service.bright_cyan(),
                port.product.bright_white(),
                port.version.bright_black()
            )
        } else {
            port.service.bright_cyan().to_string()
        }
    }

    /// Print result header
    fn print_header(header: &str, risk_level: &RiskLevel) {
        println!("\n{}", "=".repeat(header.len() + 8));
        println!("RISK: {} | {}", risk_level.display(), header);
        println!("{}", "-".repeat(header.len() + 8));
    }

    /// Print exploit list
    fn print_exploits(exploits: &[Exploit], header: &str) {
        if exploits.is_empty() {
            println!("  {} No exploits found", "SUCCESS".bright_green());
            return;
        }

        for (i, exploit) in exploits
            .iter()
            .take(constants::MAX_DISPLAYED_EXPLOITS)
            .enumerate()
        {
            Self::print_exploit_line(exploit, i, header);

            if i < exploits.len().saturating_sub(1) && i < constants::MAX_DISPLAYED_EXPLOITS - 1 {
                println!();
            }
        }

        if exploits.len() > constants::MAX_DISPLAYED_EXPLOITS {
            println!(
                "  {} {} more exploits available",
                "MORE".bright_black(),
                (exploits.len() - constants::MAX_DISPLAYED_EXPLOITS)
                    .to_string()
                    .bright_yellow()
            );
        }
    }

    /// Print individual exploit line
    fn print_exploit_line(exploit: &Exploit, index: usize, _header: &str) {
        let cvss_indicator = Self::format_cvss_indicator(exploit.cvss);

        println!(
            "  {}{} {}",
            cvss_indicator,
            (index + 1).to_string().bright_blue(),
            exploit.title
        );

        if !exploit.path.is_empty() {
            println!("    Path: {}", exploit.path.bright_black());
        }
    }

    /// Format CVSS score indicator
    fn format_cvss_indicator(cvss: Option<f32>) -> String {
        match cvss {
            Some(score) if score >= 9.0 => {
                format!(" {}{} ", "[".red(), format!("{:.1}", score).red().bold())
            }
            Some(score) if score >= 7.0 => format!(
                " {}{} ",
                "[".bright_red(),
                format!("{:.1}", score).bright_red().bold()
            ),
            Some(score) if score >= 4.0 => format!(
                " {}{} ",
                "[".yellow(),
                format!("{:.1}", score).yellow().bold()
            ),
            Some(score) => format!(" {}{} ", "[".green(), format!("{:.1}", score).green()),
            None => " [?.?] ".bright_black().to_string(),
        }
    }

    /// Print result footer
    fn print_footer(header: &str) {
        println!("{}", "=".repeat(header.len() + 8));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_risk_level_from_score() {
        assert_eq!(RiskLevel::from_score(60.0), RiskLevel::Critical);
        assert_eq!(RiskLevel::from_score(35.0), RiskLevel::High);
        assert_eq!(RiskLevel::from_score(20.0), RiskLevel::Medium);
        assert_eq!(RiskLevel::from_score(10.0), RiskLevel::Low);
    }

    #[test]
    fn test_port_result_new() {
        let port = Port::new(80);
        let exploits = vec![Exploit {
            title: "Test Exploit".to_string(),
            url: "https://example.com".to_string(),
            cvss: Some(8.0),
            path: "/test/exploit".to_string(),
        }];

        let result = PortResult::new(port, exploits);
        assert!(result.risk_score > 0.0);
        assert_eq!(result.exploits.len(), 1);
    }

    #[test]
    fn test_build_query() {
        assert_eq!(build_query("Apache", "2.4.41", "http"), "Apache 2.4.41");

        assert_eq!(build_query("", "", "ssh"), "ssh");

        assert_eq!(build_query("OpenSSH", "", "ssh"), "OpenSSH");
    }
}
