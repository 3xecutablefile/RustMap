//! # Exploit Database Integration
//! 
//! This module handles integration with exploit databases (searchsploit) and provides
//! risk assessment capabilities for detected services. It calculates risk scores
//! based on CVSS ratings, service criticality, and exploit availability.
//! 
//! ## Features
//! 
//! - Automatic exploit database queries
//! - Risk scoring with service-specific multipliers
//! - CVSS-based vulnerability assessment
//! - Categorized risk levels (Critical, High, Medium, Low)
//! - JSON serialization for integration with other tools
//! 
//! ## Example
//! 
//! ```rust
//! use rustmap::exploit::{PortResult, Exploit, RiskCalculator};
//! use rustmap::scanner::Port;
//! 
//! let port = Port::with_service(
//!     80,
//!     "http".to_string(),
//!     "Apache httpd".to_string(),
//!     "2.4.41".to_string(),
//! );
//! 
//! let exploits = vec![
//!     Exploit {
//!         title: "Apache RCE".to_string(),
//!         url: "https://example.com/exploit".to_string(),
//!         cvss: Some(9.8),
//!         path: "/apache/rce".to_string(),
//!     }
//! ];
//! 
//! let result = PortResult::new(port, exploits);
//! println!("Risk score: {:.1}", result.risk_score);
//! println!("Risk level: {:?}", result.risk_level());
//! ```

use crate::config::Config;
use crate::constants;
use crate::error::{RustMapError, Result};
use crate::external::searchsploit::{Exploit as ExternalExploit, ExploitSearcher};
use crate::scanner::Port;
use colored::*;

use serde::{Serialize, Deserialize};
use std::collections::HashSet;

/// Exploit information with risk assessment
/// 
/// This struct represents an exploit found in the database with associated
/// metadata including CVSS scores and file paths.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Exploit {
    /// Exploit title
    pub title: String,
    /// URL to exploit database entry
    pub url: String,
    /// CVSS score if available
    pub cvss: Option<f32>,
    /// File path in exploit database
    pub path: String,
}

impl From<ExternalExploit> for Exploit {
    fn from(external: ExternalExploit) -> Self {
        Self {
            title: external.title,
            url: external.url,
            cvss: external.cvss,
            path: external.path,
        }
    }
}

/// Port with associated exploits and risk score
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PortResult {
    /// Port information
    pub port: Port,
    /// List of exploits found for this port
    pub exploits: Vec<Exploit>,
    /// Calculated risk score
    pub risk_score: f32,
}

impl PortResult {
    /// Create a new port result
    pub fn new(port: Port, exploits: Vec<Exploit>) -> Self {
        let risk_score = RiskCalculator::calculate(&exploits, &port.service);
        Self {
            port,
            exploits,
            risk_score,
        }
    }
    
    /// Get risk level category
    pub fn risk_level(&self) -> RiskLevel {
        RiskLevel::from_score(self.risk_score)
    }
    
    /// Check if this is a high-risk result
    pub fn is_high_risk(&self) -> bool {
        self.risk_score >= constants::risk::HIGH
    }
}

/// Risk level categories
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RiskLevel {
    Critical,
    High,
    Medium,
    Low,
}

impl RiskLevel {
    /// Get risk level from score
    pub fn from_score(score: f32) -> Self {
        if score >= constants::risk::CRITICAL {
            Self::Critical
        } else if score >= constants::risk::HIGH {
            Self::High
        } else if score >= constants::risk::MEDIUM {
            Self::Medium
        } else {
            Self::Low
        }
    }
    
    /// Get colored display string
    pub fn display(&self) -> colored::ColoredString {
        match self {
            Self::Critical => "üî¥ CRITICAL".red().bold(),
            Self::High => "üü† HIGH".bright_red().bold(),
            Self::Medium => "üü° MEDIUM".yellow().bold(),
            Self::Low => "üü¢ LOW".green(),
        }
    }
}

/// Risk calculation utilities
pub struct RiskCalculator;

impl RiskCalculator {
    /// Calculate risk score for exploits on a service
    /// Calculate risk score from exploits and service type
    /// 
    /// This function implements a sophisticated risk scoring algorithm that considers:
    /// - Number of exploits available (capped at 10 for normalization)
    /// - CVSS scores for each exploit (default 5.0 if unknown)
    /// - Service-specific risk multipliers based on criticality
    /// 
    /// # Arguments
    /// 
    /// * `exploits` - List of exploits found for service
    /// * `service` - Service name (e.g., "http", "ssh", "smb")
    /// 
    /// # Returns
    /// 
    /// A risk score (higher values indicate greater risk)
    /// 
    /// # Example
    /// 
    /// ```rust
    /// use rustmap::exploit::{Exploit, RiskCalculator};
    /// 
    /// let exploits = vec![
    ///     Exploit {
    ///         title: "RCE Exploit".to_string(),
    ///         url: "https://example.com/rce".to_string(),
    ///         cvss: Some(9.8),
    ///         path: "/rce/exploit".to_string(),
    ///     }
    /// ];
    /// 
    /// let score = RiskCalculator::calculate(&exploits, "smb");
    /// println!("Risk score: {:.1}", score); // Will be high due to SMB multiplier
    /// ```
    pub fn calculate(exploits: &[Exploit], service: &str) -> f32 {
        let mut score = 0.0;
        
        // Base score from number of exploits (capped at 10)
        score += (exploits.len() as f32).min(10.0) * 2.0;
        
        // Add CVSS scores
        for exploit in exploits {
            if let Some(cvss) = exploit.cvss {
                score += cvss;
            } else {
                score += 5.0; // Default score for unknown CVSS
            }
        }
        
        // Apply service-specific multiplier
        let multiplier = Self::service_multiplier(service);
        score * multiplier
    }
    
    /// Get risk multiplier for specific services
    pub fn service_multiplier(service: &str) -> f32 {
        match service.to_lowercase().as_str() {
            "smb" | "netbios-ssn" | "microsoft-ds" => constants::service_multipliers::SMB,
            "mysql" | "postgresql" | "mssql" => constants::service_multipliers::DATABASE,
            "ssh" | "telnet" | "ftp" => constants::service_multipliers::REMOTE_ACCESS,
            "http" | "https" | "ssl" => constants::service_multipliers::WEB,
            _ => constants::service_multipliers::DEFAULT,
        }
    }
}

/// Search for exploits across multiple ports
/// 
/// This function orchestrates exploit searches for multiple ports, building
/// unique search queries to avoid duplicate searches and aggregating results
/// with risk assessment.
/// 
/// # Arguments
/// 
/// * `ports` - List of ports with service information
/// * `config` - Scanning configuration including timeouts
/// 
/// # Returns
/// 
/// A vector of `PortResult` structs containing exploits and risk scores
/// 
/// # Example
/// 
/// ```rust
/// use rustmap::exploit::search_exploits;
/// use rustmap::scanner::Port;
/// use rustmap::config::Config;
/// 
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let config = Config::from_args(&[
///         "rustmap".to_string(),
///         "127.0.0.1".to_string(),
///         "-1k".to_string(),
///     ])?;
///     
///     let ports = vec![
///         Port::with_service(80, "http".to_string(), "Apache".to_string(), "2.4.41".to_string()),
///         Port::with_service(22, "ssh".to_string(), "OpenSSH".to_string(), "8.2p1".to_string()),
///     ];
///     
///     let results = search_exploits(&ports, &config).await?;
///     
///     for result in results {
///         println!("Port {}: {} exploits, risk score: {:.1}", 
///                  result.port.port, result.exploits.len(), result.risk_score);
///     }
///     
///     Ok(())
/// }
/// ```
pub async fn search_exploits(ports: &[Port], config: &Config) -> Result<Vec<PortResult>> {
    if ports.is_empty() {
        return Ok(Vec::new());
    }
    
    if !config.json_mode {
        println!(
            "{} Searching exploits and calculating risk scores...\n",
            "üí•".bright_magenta()
        );
    }
    
    let searcher = ExploitSearcher::new()
        .map_err(|e| RustMapError::exploit_search(format!("Failed to initialize exploit searcher: {}", e)))?;
    
    // Collect unique search queries to avoid duplicate searches
    let queries = build_unique_queries(ports);
    
    // Perform parallel exploit searches
    let mut results = Vec::new();
    
    for (query, example_port) in queries {
        match search_port_exploits(&searcher, &query, config.exploit_timeout).await {
            Ok(exploits) => {
                if !exploits.is_empty() {
                    results.push(PortResult::new(example_port.clone(), exploits));
                }
            }
            Err(e) => {
                if !config.json_mode {
                    eprintln!("{} searchsploit error for {}: {}", "‚ö†".yellow(), query, e);
                }
            }
        }
    }
    
    // Sort by risk score (highest first)
    let mut final_results = results;
    final_results.sort_by(|a, b| {
        b.risk_score
            .partial_cmp(&a.risk_score)
            .unwrap_or(std::cmp::Ordering::Equal)
    });
    
    Ok(final_results)
}

/// Build unique search queries from port information
fn build_unique_queries(ports: &[Port]) -> Vec<(String, Port)> {
    let mut queries = Vec::new();
    let mut seen_queries = HashSet::new();
    
    for port in ports {
        let query = build_query(&port.product, &port.version, &port.service);
        if !query.is_empty() && seen_queries.insert(query.clone()) {
            queries.push((query, port.clone()));
        }
    }
    
    queries
}

/// Build search query from port information
fn build_query(product: &str, version: &str, service: &str) -> String {
    let product_version = format!("{} {}", product, version).trim().to_string();
    
    if !product_version.is_empty() && product_version != " " {
        return product_version;
    }
    
    if !product.is_empty() {
        return product.to_string();
    }
    
    service.to_string()
}

/// Search exploits for a specific port
async fn search_port_exploits(
    searcher: &ExploitSearcher,
    query: &str,
    timeout: std::time::Duration,
) -> Result<Vec<Exploit>> {
    let external_exploits = searcher
        .search_exploits(query, Some(timeout))
        .await
        .map_err(|e| RustMapError::exploit_search(format!("Search failed for query '{}': {}", query, e)))?;
    
    Ok(external_exploits.into_iter().map(Exploit::from).collect())
}

/// Print exploit analysis results
pub fn print_results(results: &[PortResult], all_ports: &[Port]) {
    if !results.is_empty() {
        print_exploit_results(results);
        print_summary(results);
    } else {
        print_no_exploits_found(all_ports);
    }
}

/// Print detailed exploit results
fn print_exploit_results(results: &[PortResult]) {
    println!("\n{} Exploit Analysis Results:", "üí•".bright_magenta().bold());
    for result in results {
        ResultPrinter::print_single_result(result);
    }
}

/// Print summary statistics
fn print_summary(results: &[PortResult]) {
    let total_exploits: usize = results.iter().map(|r| r.exploits.len()).sum();
    let high_risk_count = results.iter().filter(|r| r.is_high_risk()).count();
    
    println!("\n{} Summary:", "üìä".bright_cyan().bold());
    println!(
        "  {} Total exploits found: {}",
        "‚Üí".bright_blue(),
        total_exploits.to_string().bright_yellow()
    );
    println!(
        "  {} High-risk services: {}",
        "‚Üí".bright_blue(),
        high_risk_count.to_string().bright_red()
    );
    println!(
        "  {} Services analyzed: {}",
        "‚Üí".bright_blue(),
        results.len().to_string().bright_green()
    );
}

/// Print message when no exploits are found
fn print_no_exploits_found(ports: &[Port]) {
    println!(
        "\n{} No exploits found for detected services.",
        "‚úì".bright_green()
    );
    
    if !ports.is_empty() {
        println!("\n{} Secure Services:", "üõ°Ô∏è".bright_green().bold());
        for port in ports {
            let service_info = if !port.product.is_empty() {
                format!(
                    "{} {} {}",
                    port.service.bright_cyan(),
                    port.product.bright_white(),
                    port.version.bright_black()
                )
            } else {
                port.service.bright_cyan().to_string()
            };
            println!(
                "  {} Port {}: {}",
                "‚Üí".bright_blue(),
                port.port,
                service_info
            );
        }
    }
    
    println!("\n{} This is good! However, keep in mind:", "üí°".bright_yellow().bold());
    println!("  {} No public exploits ‚â† No vulnerabilities", "‚Ä¢".bright_yellow());
    println!("  {} Always verify services are up-to-date", "‚Ä¢".bright_yellow());
    println!("  {} Consider running additional security scans", "‚Ä¢".bright_yellow());
}

/// Utility for printing individual results
struct ResultPrinter;

impl ResultPrinter {
    /// Print a single port result with formatted output
    fn print_single_result(result: &PortResult) {
        let port = &result.port;
        let exploits = &result.exploits;
        let risk_level = result.risk_level();
        
        let service_info = Self::format_service_info(port);
        let header = format!(
            "Port {} | {} | Risk: {:.1} | {} exploits",
            port.port, service_info, result.risk_score, exploits.len()
        );
        
        Self::print_header(&header, &risk_level);
        Self::print_exploits(exploits, &header);
        Self::print_footer(&header);
    }
    
    /// Format service information for display
    fn format_service_info(port: &Port) -> String {
        if !port.product.is_empty() {
            format!(
                "{} {} {}",
                port.service.bright_cyan(),
                port.product.bright_white(),
                port.version.bright_black()
            )
        } else {
            port.service.bright_cyan().to_string()
        }
    }
    
    /// Print result header
    fn print_header(header: &str, risk_level: &RiskLevel) {
        println!(
            "\n{}‚ï≠{}‚ïÆ",
            "‚îÉ".bright_black(),
            "‚îÅ".repeat(header.len() + 4)
        );
        println!(
            "{}‚îÇ {} {} {}‚îÇ",
            "‚îÉ".bright_black(),
            risk_level.display(),
            header,
            "‚îÉ".bright_black()
        );
        println!(
            "{}‚îú{}‚î§",
            "‚îÉ".bright_black(),
            "‚îÄ".repeat(header.len() + 4)
        );
    }
    
    /// Print exploit list
    fn print_exploits(exploits: &[Exploit], header: &str) {
        if exploits.is_empty() {
            println!(
                "{}‚îÇ  {} No exploits found {}‚îÇ",
                "‚îÉ".bright_black(),
                "‚úì".bright_green(),
                "‚îÉ".bright_black()
            );
            return;
        }
        
        for (i, exploit) in exploits.iter().take(constants::MAX_DISPLAYED_EXPLOITS).enumerate() {
            Self::print_exploit_line(exploit, i, header);
            
            if i < exploits.len().saturating_sub(1) && i < constants::MAX_DISPLAYED_EXPLOITS - 1 {
                println!(
                    "{}‚îÇ{}‚îÇ",
                    "‚îÉ".bright_black(),
                    " ".repeat(header.len() + 2)
                );
            }
        }
        
        if exploits.len() > constants::MAX_DISPLAYED_EXPLOITS {
            println!(
                "{}‚îÇ  {} {} more exploits available {}‚îÇ",
                "‚îÉ".bright_black(),
                "...".bright_black(),
                (exploits.len() - constants::MAX_DISPLAYED_EXPLOITS).to_string().bright_yellow(),
                "‚îÉ".bright_black()
            );
        }
    }
    
    /// Print individual exploit line
    fn print_exploit_line(exploit: &Exploit, index: usize, _header: &str) {
        let cvss_indicator = Self::format_cvss_indicator(exploit.cvss);
        
        println!(
            "{}‚îÇ{} {} {} {}‚îÇ",
            "‚îÉ".bright_black(),
            cvss_indicator,
            (index + 1).to_string().bright_blue(),
            exploit.title,
            "‚îÉ".bright_black()
        );
        
        if !exploit.path.is_empty() {
            println!(
                "{}‚îÇ    {} {}‚îÇ",
                "‚îÉ".bright_black(),
                exploit.path.bright_black(),
                "‚îÉ".bright_black()
            );
        }
    }
    
    /// Format CVSS score indicator
    fn format_cvss_indicator(cvss: Option<f32>) -> String {
        match cvss {
            Some(score) if score >= 9.0 => format!(" {}{} ", "[".red(), format!("{:.1}", score).red().bold()),
            Some(score) if score >= 7.0 => format!(" {}{} ", "[".bright_red(), format!("{:.1}", score).bright_red().bold()),
            Some(score) if score >= 4.0 => format!(" {}{} ", "[".yellow(), format!("{:.1}", score).yellow().bold()),
            Some(score) => format!(" {}{} ", "[".green(), format!("{:.1}", score).green()),
            None => " [?.?] ".bright_black().to_string(),
        }
    }
    
    /// Print result footer
    fn print_footer(header: &str) {
        println!(
            "{}‚ï∞{}‚ïØ",
            "‚îÉ".bright_black(),
            "‚îÅ".repeat(header.len() + 4)
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_risk_level_from_score() {
        assert_eq!(RiskLevel::from_score(60.0), RiskLevel::Critical);
        assert_eq!(RiskLevel::from_score(35.0), RiskLevel::High);
        assert_eq!(RiskLevel::from_score(20.0), RiskLevel::Medium);
        assert_eq!(RiskLevel::from_score(10.0), RiskLevel::Low);
    }
    
    #[test]
    fn test_port_result_new() {
        let port = Port::new(80);
        let exploits = vec![
            Exploit {
                title: "Test Exploit".to_string(),
                url: "https://example.com".to_string(),
                cvss: Some(8.0),
                path: "/test/exploit".to_string(),
            }
        ];
        
        let result = PortResult::new(port, exploits);
        assert!(result.risk_score > 0.0);
        assert_eq!(result.exploits.len(), 1);
    }
    
    #[test]
    fn test_build_query() {
        assert_eq!(
            build_query("Apache", "2.4.41", "http"),
            "Apache 2.4.41"
        );
        
        assert_eq!(
            build_query("", "", "ssh"),
            "ssh"
        );
        
        assert_eq!(
            build_query("OpenSSH", "", "ssh"),
            "OpenSSH"
        );
    }
}