#[cfg(test)]
mod tests {
    use rustmap::exploit::{Exploit, PortResult, RiskLevel, RiskCalculator, search_exploits};
    use rustmap::scanner::Port;
    use rustmap::config::Config;
    use rustmap::constants::risk;
    use std::time::Duration;

    #[test]
    fn test_exploit_creation() {
        let exploit = Exploit {
            title: "Test Exploit".to_string(),
            url: "https://example.com/exploit".to_string(),
            cvss: Some(9.8),
            path: "/path/to/exploit".to_string(),
        };

        assert_eq!(exploit.title, "Test Exploit");
        assert_eq!(exploit.url, "https://example.com/exploit");
        assert_eq!(exploit.cvss, Some(9.8));
        assert_eq!(exploit.path, "/path/to/exploit");
    }

    #[test]
    fn test_port_result_creation() {
        let port = Port::new(80);
        let exploits = vec![
            Exploit {
                title: "HTTP Exploit".to_string(),
                url: "https://example.com/http".to_string(),
                cvss: Some(7.5),
                path: "/http/exploit".to_string(),
            }
        ];

        let result = PortResult::new(port, exploits);
        assert_eq!(result.port.port, 80);
        assert_eq!(result.exploits.len(), 1);
        assert!(result.risk_score > 0.0);
    }

    #[test]
    fn test_risk_level_from_score() {
        assert_eq!(RiskLevel::from_score(60.0), RiskLevel::Critical);
        assert_eq!(RiskLevel::from_score(40.0), RiskLevel::High);
        assert_eq!(RiskLevel::from_score(20.0), RiskLevel::Medium);
        assert_eq!(RiskLevel::from_score(10.0), RiskLevel::Low);
    }

    #[test]
    fn test_risk_level_display() {
        let critical = RiskLevel::Critical;
        let high = RiskLevel::High;
        let medium = RiskLevel::Medium;
        let low = RiskLevel::Low;

        // Test that display methods don't panic and return strings
        let _ = critical.display();
        let _ = high.display();
        let _ = medium.display();
        let _ = low.display();
    }

    #[test]
    fn test_port_result_risk_level() {
        let port = Port::with_service(22, "ssh".to_string(), "OpenSSH".to_string(), "7.4".to_string());
        let exploits = vec![
            Exploit {
                title: "SSH Exploit".to_string(),
                url: "https://example.com/ssh".to_string(),
                cvss: Some(9.8),
                path: "/ssh/exploit".to_string(),
            }
        ];

        let result = PortResult::new(port, exploits);
        let risk_level = result.risk_level();
        
        // Should be high risk due to SSH service and high CVSS
        assert!(risk_level == RiskLevel::Critical || risk_level == RiskLevel::High || risk_level == RiskLevel::Medium);
    }

    #[test]
    fn test_port_result_is_high_risk() {
        let port = Port::with_service(80, "http".to_string(), "Apache".to_string(), "2.4.41".to_string());
        let exploits = vec![
            Exploit {
                title: "Web Exploit 1".to_string(),
                url: "https://example.com/web1".to_string(),
                cvss: Some(9.0),
                path: "/web/exploit1".to_string(),
            },
            Exploit {
                title: "Web Exploit 2".to_string(),
                url: "https://example.com/web2".to_string(),
                cvss: Some(8.0),
                path: "/web/exploit2".to_string(),
            }
        ];

        let result = PortResult::new(port, exploits);
        // Base: 2×2.0 = 4.0, CVSS: 9.0+8.0=17.0, Total: 21.0 × 1.3 (WEB) = 27.3 (above MEDIUM)
        assert!(result.risk_score >= risk::HIGH || result.risk_score >= risk::MEDIUM);
    }

    #[test]
    fn test_port_result_low_risk() {
        let port = Port::new(80);
        let exploits = vec![
            Exploit {
                title: "Low Risk Exploit".to_string(),
                url: "https://example.com/low".to_string(),
                cvss: Some(3.0),
                path: "/low/exploit".to_string(),
            }
        ];

        let result = PortResult::new(port, exploits);
        assert!(!result.is_high_risk());
    }

    #[test]
    fn test_risk_calculator_no_exploits() {
        let exploits = vec![];
        let service = "http";
        let risk_score = RiskCalculator::calculate(&exploits, service);
        assert_eq!(risk_score, 0.0);
    }

    #[test]
    fn test_risk_calculator_with_cvss() {
        let exploits = vec![
            Exploit {
                title: "High CVSS Exploit".to_string(),
                url: "https://example.com/high".to_string(),
                cvss: Some(9.8),
                path: "/high/exploit".to_string(),
            }
        ];
        let service = "smb";
        let risk_score = RiskCalculator::calculate(&exploits, service);
        assert!(risk_score > 20.0); // Should be high due to SMB service multiplier (1.8)
    }

    #[test]
    fn test_risk_calculator_multiple_exploits() {
        let exploits = vec![
            Exploit {
                title: "Exploit 1".to_string(),
                url: "https://example.com/1".to_string(),
                cvss: Some(7.5),
                path: "/1/exploit".to_string(),
            },
            Exploit {
                title: "Exploit 2".to_string(),
                url: "https://example.com/2".to_string(),
                cvss: Some(5.0),
                path: "/2/exploit".to_string(),
            },
            Exploit {
                title: "Exploit 3".to_string(),
                url: "https://example.com/3".to_string(),
                cvss: None,
                path: "/3/exploit".to_string(),
            }
        ];
        let service = "http";
        let risk_score = RiskCalculator::calculate(&exploits, service);
        assert!(risk_score > 0.0);
        assert!(risk_score < 50.0); // Should not be critical for HTTP with these scores
    }

    #[test]
    fn test_service_multipliers() {
        let exploits = vec![
            Exploit {
                title: "Test Exploit".to_string(),
                url: "https://example.com/test".to_string(),
                cvss: Some(5.0),
                path: "/test/exploit".to_string(),
            }
        ];

        let smb_score = RiskCalculator::calculate(&exploits, "smb");
        let http_score = RiskCalculator::calculate(&exploits, "http");
        let default_score = RiskCalculator::calculate(&exploits, "unknown");

        assert!(smb_score > http_score);
        assert!(smb_score > default_score);
        assert!(http_score > default_score);
    }

    #[tokio::test]
    async fn test_search_exploits_empty_ports() {
        let empty_ports: Vec<Port> = vec![];
        let config = Config::from_args(&[
            "rustmap".to_string(),
            "127.0.0.1".to_string(),
            "-1k".to_string(),
        ]).unwrap();

        let result = search_exploits(&empty_ports, &config).await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty());
    }

    #[tokio::test]
    async fn test_search_exploits_with_ports() {
        let ports = vec![
            Port::with_service(
                80,
                "http".to_string(),
                "Apache httpd".to_string(),
                "2.4.41".to_string(),
            ),
            Port::with_service(
                22,
                "ssh".to_string(),
                "OpenSSH".to_string(),
                "8.2p1".to_string(),
            ),
        ];

        let config = Config::from_args(&[
            "rustmap".to_string(),
            "127.0.0.1".to_string(),
            "-1k".to_string(),
            "--exploit-timeout".to_string(),
            "5000".to_string(), // Short timeout for testing
        ]).unwrap();

        let result = search_exploits(&ports, &config).await;
        
        // Result should be Ok even if searchsploit is not available
        // The function should handle missing tools gracefully
        assert!(result.is_ok());
        
        let results = result.unwrap();
        // Should have results only for ports with exploits found
        // When searchsploit is not available, no exploits will be found
        assert_eq!(results.len(), 0);
    }

    #[test]
    fn test_exploit_timeout_configuration() {
        let config = Config::from_args(&[
            "rustmap".to_string(),
            "127.0.0.1".to_string(),
            "-1k".to_string(),
            "--exploit-timeout".to_string(),
            "15000".to_string(),
        ]).unwrap();
        
        assert_eq!(config.exploit_timeout, Duration::from_millis(15000));
    }

    #[test]
    fn test_port_result_serialization() {
        let port = Port::new(443);
        let exploits = vec![
            Exploit {
                title: "HTTPS Exploit".to_string(),
                url: "https://example.com/https".to_string(),
                cvss: Some(6.5),
                path: "/https/exploit".to_string(),
            }
        ];

        let result = PortResult::new(port, exploits);
        
        // Test that the result can be serialized
        let json = serde_json::to_string(&result);
        assert!(json.is_ok());
    }

    #[test]
    fn test_exploit_serialization() {
        let exploit = Exploit {
            title: "Test Exploit".to_string(),
            url: "https://example.com/test".to_string(),
            cvss: Some(7.8),
            path: "/test/exploit".to_string(),
        };

        let json = serde_json::to_string(&exploit);
        assert!(json.is_ok());
    }
}